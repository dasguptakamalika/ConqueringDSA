class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String s : strs) {
            // Sort the string to create a key
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            
            // If key doesn't exist, create a new list for it
            if (!map.containsKey(key)) {
                map.put(key, new ArrayList<>());
            }
            
            // Add the original string to the list,That line is what actually puts data into the buckets.
            //âœ… .add() only: works on collections like List ,adds one element of the correct type
            map.get(key).add(s);
        }
        
        return new ArrayList<>(map.values());
    }
}
/* In Java, a Map key can NOT exist without a value.
So when you do:
map.put(key, new ArrayList<>());
you are:
creating the key
AND assigning it a value
that value happens to be an empty ArrayList
There is no such thing as a â€œkey-onlyâ€ entry in a Java Map. */
/*s = "eat"
chars = ['e','a','t']
sorted â†’ ['a','e','t']
key = "aet"
Map before:
(empty)
Key doesnâ€™t exist â†’ create bucket:
"aet" â†’ []
Now add value:
map.get("aet").add("eat");
Map becomes:
"aet" â†’ ["eat"]
Iteration 2
s = "tea"
chars = ['t','e','a']
sorted â†’ ['a','e','t']
key = "aet"
Key exists â†’ reuse same bucket
map.get("aet").add("tea");
Map now:
"aet" â†’ ["eat", "tea"]
Iteration 3
s = "tan"
sorted â†’ "ant"
Key not found â†’ create new bucket:
"ant" â†’ []
Add value:
"ant" â†’ ["tan"]
Final Map in memory ğŸ§ 
"aet" â†’ ["eat", "tea"]
"ant" â†’ ["tan"] */
