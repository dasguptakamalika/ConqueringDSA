 class Solution 
{
    public int pivotIndex(int[] nums)
       {
     int sum=0;
     //calculate the total sum, run the for loop
     for(int num : nums)
          {
         sum+=num;
          }

     //calculate pivot index
     int leftSum = 0;
for(int i=0;i<nums.length ;i++)
{
    if(leftSum==sum- leftSum - nums[i])
    {
        return i;
    }
    leftSum +=nums[i];
}
 
 return -1;
       }
}


#brute force
class Solution {
    public int pivotIndex(int[] nums) {
        int n = nums.length;

        for (int i = 0; i < n; i++) {

            int leftSum = 0;
            int rightSum = 0;

            // calculate left sum
            for (int l = 0; l < i; l++) {
                leftSum += nums[l];
            }

            // calculate right sum
            for (int r = i + 1; r < n; r++) {
                rightSum += nums[r];
            }

            if (leftSum == rightSum) {
                return i;
            }
        }

        return -1;
    }
}


//totalSum includes the pivot element, and pivot should not belong to either side.

/* nums = [0, 1, -1, 0]
Check:
index 0 â†’ left = 0, right = 0 âœ”ï¸ pivot
index 3 â†’ left = 0, right = 0 âœ”ï¸ pivot
ðŸ‘‰ Answer = 0, not 3
Because 0 is the leftmost pivot

3ï¸âƒ£ Check each index as a possible pivot
ðŸ”¹ Index = 0
Left side:
Elements before index 0 â†’ âŒ none
So left sum = 0
âœ”ï¸ This is explicitly stated in the problem
Right side:
Elements after index 0 â†’ [1, -1]
Right sum = 1 + (-1) = 0
âœ… Left sum == Right sum
ðŸ‘‰ Index 0 IS a pivot
ðŸ”¹ Index = 1 (just to understand)
Left side:
[2] â†’ sum = 2
Right side:
[-1] â†’ sum = -1
âŒ Not equal â†’ not a pivot
ðŸ”¹ Index = 2
Left side:
[2, 1] â†’ sum = 3
Right side:
none â†’ sum = 0
âŒ Not equal  */
